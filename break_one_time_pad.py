# Description: In this tiny program, a technique called crip dragging is implemented fully to break one time pad when the pad was used multiple times to encrypt 11 messages. The program outputs all the messages since we guessed correctly certain words.

import codecs
from hashlib import sha256

mes_length = 33

messages_ciphers = "00 0d 16 25 1c 07 04 4b 36 17 1c 03 07 28 08 58 29 14 03 50 0a 20 03 45 00 29 00 1e 59 30 07 0e 52 0d 0d 15 71 3c 49 00 0a 2c 52 1d 12 0f 22 4f 01 25 00 4d 00 16 3d 10 00 11 38 0d 03 59 33 0a 0b 4d 15 1f 00 22 1a 04 06 4b 2d 1c 0a 57 1a 2f 02 1d 6a 05 0c 14 53 26 05 45 05 23 13 11 10 2a 08 47 01 0d 09 1c 71 02 0c 43 08 23 1c 4f 1a 0f 2d 0a 58 2c 00 03 50 1c 29 56 2b 1b 2f 0e 09 59 2a 00 10 01 1d 48 0d 3e 05 0c 43 05 2d 52 1c 03 1b 22 0a 16 3e 55 0e 11 1d 6f 04 00 13 28 41 0e 11 2d 1c 47 01 00 00 04 25 55 1e 0c 1e 2e 16 4f 15 0b 66 1e 0d 23 01 08 50 16 22 14 04 00 3e 00 09 0a 2d 01 00 01 18 1d 06 3a 1c 05 1a 4b 0d 26 3f 57 07 35 4f 08 2f 07 0b 15 10 3b 1a 1c 52 3f 04 19 0b 21 1b 47 01 10 01 01 3f 01 49 2d 02 21 1d 1c 57 1d 27 16 58 3e 1d 08 02 16 6f 01 04 01 6c 00 5a 1a 25 1b 04 49 19 09 1c 33 10 49 1a 0e 36 52 26 57 0a 2f 0b 16 3e 55 1d 11 0a 6f 17 11 06 29 0f 0e 10 2b 01 47 01 03 0d 45 22 1d 06 16 07 26 52 1d 12 0f 2a 03 01 6a 19 04 03 07 2a 18 45 06 23 41 34 10 27 00 14 01 1a 09 0d 71 02 0c 43 0a 30 17 4f 13 01 2f 01 1f 6a 02 08 1c 1f 6f 01 0c 06 24 0e 0f 0d 64 07 0e 4c"

hex_list_cipher_1 = messages_ciphers.split()
frequency_dict = {}
# init the frequency dictionary
for h in hex_list_cipher_1:
    frequency_dict[h] = 0

for h in hex_list_cipher_1:
    freq = frequency_dict[h]
    freq+=1
    frequency_dict[h] = freq

order_freq = dict(sorted(frequency_dict.items(), key=lambda item: item[1]))
most_freq_hex = list(order_freq.keys())[-1]

# now that we know the frequencies of each hex, this might help us in guessing, but first let's XOR the first 3 messages
hex_message_1 = 0x000d16251c07044b36171c0307280858291403500a2003450029001e5930070e52
hex_message_2 = 0x0d0d15713c49000a2c521d120f224f0125004d00163d100011380d0359330a0b4d
hex_message_3 = 0x151f00221a04064b2d1c0a571a2f021d6a050c145326054505231311102a084701
hex_message_4 = 0x0d091c71020c4308231c4f1a0f2d0a582c0003501c29562b1b2f0e09592a001001
hex_message_5 = 0x1d480d3e050c43052d521c031b220a163e550e111d6f04001328410e112d1c4701
hex_message_6 = 0x00000425551e0c1e2e164f150b661e0d2301085016221404003e00090a2d010001
hex_message_7 = 0x181d063a1c051a4b0d263f5707354f082f070b15103b1a1c523f04190b211b4701
hex_message_8 = 0x1001013f01492d02211d1c571d2716583e1d0802166f0104016c005a1a251b0449
hex_message_9 = 0x19091c3310491a0e365226570a2f0b163e551d110a6f171106290f0e102b014701
hex_message_10 = 0x030d45221d06160726521d120f2a03016a190403072a1845062341341027001401
hex_message_11 = 0x1a090d71020c430a30174f13012f011f6a02081c1f6f010c06240e0f0d64070e4c

list_hex_xors = [hex_message_1, hex_message_2, hex_message_3, hex_message_4, hex_message_5, hex_message_6, hex_message_7, hex_message_8, hex_message_9, hex_message_10, hex_message_11]

# now lets go with "the " since that is the most common word in english and it also has a space. lets see if anything makes sense in any text
# convert "the " to hex
# string should be of the size of 1 message so it's easier doing Xor opeartions
def empty_the_string(n):
    string_to_check = ''
    for i in range(mes_length):
        string_to_check += n
    return string_to_check

# here i am simply putting the word in the string
def put_word_in_string(offset, word, big_string):
    big_string = list(big_string)
    for l in range(len(word)):
        big_string[offset+l] = word[l]
    return "".join(big_string)

f = open("dump.txt", "a")
guess_word = "Testing testing can you read this"
# as we find words, we will update string_to_check so we have the words where they should be (we keep track of that manually)
off = 0
while off <= (mes_length-len(guess_word)):
    string_to_pass = empty_the_string(' ')
    string_to_pass = put_word_in_string(off, guess_word ,string_to_pass).encode('ASCII').hex()
   
    # keep in mind we do not know in which specific message this plaintext is coming from
    for i in range(0, len(list_hex_xors)):
        for j in range(i,len(list_hex_xors)):
            if (i==j):
                continue
            xorHex = hex(list_hex_xors[i] ^ list_hex_xors[j])
            
            possible_plain_text = hex(int(string_to_pass,16) ^ int(xorHex[2:],16))
            decoded_text = codecs.decode(possible_plain_text[2:], "hex").decode('ascii')
            temp = decoded_text
            if temp[off:(off+len(guess_word))].replace(" ", "").replace(".", "").replace(",", "").replace("!", "").replace("?", "").replace("'", "").isalpha():
        
                empty_out = empty_the_string('-')
                print( str(i+1),str(j+1),str(off) + " |" + empty_out[0:off]+temp[off:(off+len(guess_word))]+empty_out[len(guess_word):] + "|")
                
    off+=1

# here we have found all the messages. so now let me get that and xor with cipher to get key. Second part of the assignment where we must try to decipher all future keys
plain_text_hex = "Yep I can read you perfectly well".encode('ASCII').hex()
key_hex = hex(int(plain_text_hex,16) ^ hex_message_2)[2:]
print("key 0: "+key_hex)

# lets go ahead and do multiple iterations of this
number_of_midnights = 30
for n in range(number_of_midnights):
    bytes_key = bytes.fromhex(key_hex)
    hashh = sha256(bytes_key)
    sha_newKeyhex = hashh.hexdigest()
 
    # now append binary and turn back to hex

    bto_append = "00100001"
    hex_to_append = "21" # the previous binary converted to hex is this
    
    new_key = sha_newKeyhex+hex_to_append
    key_hex = new_key
    print(f"key {n+1}: "+key_hex)

